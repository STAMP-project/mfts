/*
 * generated by Xtext 2.12.0
 */
package eu.stamp.mfts.generator

import eu.stamp.mfts.mFTS.Action
import eu.stamp.mfts.mFTS.Model
import eu.stamp.mfts.mFTS.Send
import eu.stamp.mfts.mFTS.Seq
import eu.stamp.mfts.mFTS.Service
import eu.stamp.mfts.mFTS.TestSequence
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.emf.ecore.EObject
import eu.stamp.mfts.mFTS.Message
import eu.stamp.mfts.mFTS.Wait
import eu.stamp.mfts.mFTS.Par
import eu.stamp.mfts.mFTS.Expect
import eu.stamp.mfts.mFTS.Expression
import java.util.List
import eu.stamp.mfts.mFTS.StringLiteral
import eu.stamp.mfts.mFTS.BooleanLiteral
import eu.stamp.mfts.mFTS.IntegerLiteral
import eu.stamp.mfts.mFTS.DoubleLiteral
import eu.stamp.mfts.mFTS.ByteLiteral
import eu.stamp.mfts.mFTS.CharLiteral
import eu.stamp.mfts.mFTS.ExternExpression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MFTSGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		resource.allContents.filter(Model).forEach[ m, i | 
			val builder = new StringBuilder();
			generate(m, builder)
			fsa.generateFile('test' + i + '.plantuml', builder.toString)	
		]
	}
	
	private def void generate(Model m, StringBuilder builder) {
		builder.append("@startuml\n");
		m.tests.forEach[ t | 
			generate(t, builder)
		]
		builder.append("@enduml\n");
	}
	
	private def void generate(TestSequence t, StringBuilder builder) {
		builder.append("participant " + t.name + " #LightBlue\n")
		generate(t.actions, builder)
	}
	
	private def dispatch void generate(Action t, StringBuilder builder) {
		System.err.println("Action " + t.class.name + " is not implemented yet. Please contact Franck Fleurey!")
		//throw new UnsupportedOperationException("Action " + t.class.name + " is not implemented yet. Please contact Franck Fleurey!")
	}
	
	private def dispatch void generate(Seq s, StringBuilder builder) {
		s.actions.forEach[ a | 
			generate(a, builder)
		]
	}
	
	private def TestSequence findTestSequence(EObject o) {
		var EObject parent = o.eContainer
		while (!(parent instanceof TestSequence)) {
			parent = parent.eContainer
		}
		return parent as TestSequence
	}
	
	private def dispatch void generate(Wait w, StringBuilder builder) {
		builder.append("...Wait[" + w.time.min + "," + w.time.max + "]...\n")
	}
	
	private def dispatch void generate(Send s, StringBuilder builder) {
		val from = findTestSequence(s)
		builder.append("\n")
		builder.append(from.name)
		builder.append(" -> ")
		builder.append(s.service.name)
		builder.append(" : ")
		generate(s.message, s.parameters, builder)
		builder.append("\n");
	}
	
	private def dispatch void generate(Par p, StringBuilder builder) {
		builder.append("par ")
		builder.append(p.time.min + "," + p.time.max)
		builder.append("\n")
		p.actions.forEach[ a | 
			builder.append("else ")
			generate(a, builder)
		]
		builder.append("end\n")
	}
	
	private def dispatch void generate(Expect e, StringBuilder builder) {
		val to = findTestSequence(e)
		builder.append(e.time.min + "," + e.time.max + "\n")
		builder.append(e.service.name)
		builder.append(" -[#green]> ")
		builder.append(to.name)
		builder.append(" : ")
		generate(e.message, null, builder)
		if (!e.asserts.empty) {
			builder.append("\nnote right:")
			e.asserts.forEach[ a,i | 
				if (i>0) {
					builder.append(" and ")
				}
				generate(a, builder)
			]
		}
		builder.append("\n");
	}	
	
	private def void generate(Message m, List<Expression> params, StringBuilder builder) {
		builder.append(m.name)
		builder.append("(")
		if (params !== null) {
			params.forEach[p,i | 
				if (i > 0) {
					builder.append(",")
				}
				generate(p, builder)
			]
		} else {
			builder.append(m.parameters.map[p | p.name].join(","))
		}
		builder.append(")")
	}
	
	private def dispatch void generate(Expression e, StringBuilder builder) {
		System.err.println("Expression " + e.class.name + " is not implemented yet. Please contact Franck Fleurey!")
		//throw new UnsupportedOperationException("Expression " + e.class.name + " is not implemented yet. Please contact Franck Fleurey!")
	}
	
	private def dispatch void generate(StringLiteral e, StringBuilder builder) {
		builder.append("\"" + e.stringValue + "\"")
	}
	
	private def dispatch void generate(BooleanLiteral e, StringBuilder builder) {
		builder.append(e.boolValue)
	}	
	
	private def dispatch void generate(IntegerLiteral e, StringBuilder builder) {
		builder.append(e.intValue)
	}
	
	private def dispatch void generate(DoubleLiteral e, StringBuilder builder) {
		builder.append(e.doubleValue)
	}
	
	private def dispatch void generate(ByteLiteral e, StringBuilder builder) {
		builder.append(e.byteValue)
	}	
	
	private def dispatch void generate(CharLiteral e, StringBuilder builder) {
		builder.append(e.charValue)
	}
	
	private def dispatch void generate(ExternExpression e, StringBuilder builder) {
		//builder.append("`")
		builder.append(e.expression)
		//builder.append("`")
		e.segments.forEach[ exp |
			builder.append(" & ") 
			generate(exp, builder)
		]
	}	
}
