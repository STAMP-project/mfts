/*
 * generated by Xtext 2.12.0
 */
package eu.stamp.mfts.serializer;

import com.google.inject.Inject;
import eu.stamp.mfts.mFTS.BooleanLiteral;
import eu.stamp.mfts.mFTS.ByteLiteral;
import eu.stamp.mfts.mFTS.CharLiteral;
import eu.stamp.mfts.mFTS.DoubleLiteral;
import eu.stamp.mfts.mFTS.Expect;
import eu.stamp.mfts.mFTS.ExternExpression;
import eu.stamp.mfts.mFTS.IntegerLiteral;
import eu.stamp.mfts.mFTS.MFTSPackage;
import eu.stamp.mfts.mFTS.Message;
import eu.stamp.mfts.mFTS.Model;
import eu.stamp.mfts.mFTS.Par;
import eu.stamp.mfts.mFTS.PlatformAnnotation;
import eu.stamp.mfts.mFTS.Send;
import eu.stamp.mfts.mFTS.Seq;
import eu.stamp.mfts.mFTS.Service;
import eu.stamp.mfts.mFTS.ServiceInterface;
import eu.stamp.mfts.mFTS.StringLiteral;
import eu.stamp.mfts.mFTS.TestSequence;
import eu.stamp.mfts.mFTS.TimeInterval;
import eu.stamp.mfts.mFTS.Wait;
import eu.stamp.mfts.services.MFTSGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MFTSSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MFTSGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MFTSPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MFTSPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case MFTSPackage.BYTE_LITERAL:
				sequence_ByteLiteral(context, (ByteLiteral) semanticObject); 
				return; 
			case MFTSPackage.CHAR_LITERAL:
				sequence_CharLiteral(context, (CharLiteral) semanticObject); 
				return; 
			case MFTSPackage.DOUBLE_LITERAL:
				sequence_DoubleLiteral(context, (DoubleLiteral) semanticObject); 
				return; 
			case MFTSPackage.EXPECT:
				sequence_Expect(context, (Expect) semanticObject); 
				return; 
			case MFTSPackage.EXTERN_EXPRESSION:
				sequence_ExternExpression(context, (ExternExpression) semanticObject); 
				return; 
			case MFTSPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case MFTSPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case MFTSPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MFTSPackage.PAR:
				sequence_Par(context, (Par) semanticObject); 
				return; 
			case MFTSPackage.PARAMETER:
				sequence_Parameter(context, (eu.stamp.mfts.mFTS.Parameter) semanticObject); 
				return; 
			case MFTSPackage.PLATFORM_ANNOTATION:
				sequence_PlatformAnnotation(context, (PlatformAnnotation) semanticObject); 
				return; 
			case MFTSPackage.SEND:
				sequence_Send(context, (Send) semanticObject); 
				return; 
			case MFTSPackage.SEQ:
				sequence_Seq(context, (Seq) semanticObject); 
				return; 
			case MFTSPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case MFTSPackage.SERVICE_INTERFACE:
				sequence_ServiceInterface(context, (ServiceInterface) semanticObject); 
				return; 
			case MFTSPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case MFTSPackage.TEST_SEQUENCE:
				sequence_TestSequence(context, (TestSequence) semanticObject); 
				return; 
			case MFTSPackage.TIME_INTERVAL:
				sequence_TimeInterval(context, (TimeInterval) semanticObject); 
				return; 
			case MFTSPackage.WAIT:
				sequence_Wait(context, (Wait) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     boolValue?='true'?
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ByteLiteral
	 *     ByteLiteral returns ByteLiteral
	 *
	 * Constraint:
	 *     byteValue=BYTE
	 */
	protected void sequence_ByteLiteral(ISerializationContext context, ByteLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MFTSPackage.Literals.BYTE_LITERAL__BYTE_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MFTSPackage.Literals.BYTE_LITERAL__BYTE_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getByteLiteralAccess().getByteValueBYTETerminalRuleCall_0(), semanticObject.getByteValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CharLiteral
	 *     CharLiteral returns CharLiteral
	 *
	 * Constraint:
	 *     charValue=CHAR
	 */
	protected void sequence_CharLiteral(ISerializationContext context, CharLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MFTSPackage.Literals.CHAR_LITERAL__CHAR_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MFTSPackage.Literals.CHAR_LITERAL__CHAR_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharLiteralAccess().getCharValueCHARTerminalRuleCall_0(), semanticObject.getCharValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DoubleLiteral
	 *     DoubleLiteral returns DoubleLiteral
	 *
	 * Constraint:
	 *     doubleValue=FLOAT
	 */
	protected void sequence_DoubleLiteral(ISerializationContext context, DoubleLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MFTSPackage.Literals.DOUBLE_LITERAL__DOUBLE_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MFTSPackage.Literals.DOUBLE_LITERAL__DOUBLE_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoubleLiteralAccess().getDoubleValueFLOATTerminalRuleCall_0(), semanticObject.getDoubleValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Expect
	 *     Expect returns Expect
	 *
	 * Constraint:
	 *     (service=[Service|ID] message=[Message|ID] time=TimeInterval annotations+=PlatformAnnotation* asserts+=Expression*)
	 */
	protected void sequence_Expect(ISerializationContext context, Expect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExternExpression
	 *     ExternExpression returns ExternExpression
	 *
	 * Constraint:
	 *     (expression=EXTERN segments+=Expression*)
	 */
	protected void sequence_ExternExpression(ISerializationContext context, ExternExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     intValue=INT
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MFTSPackage.Literals.INTEGER_LITERAL__INT_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MFTSPackage.Literals.INTEGER_LITERAL__INT_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getIntValueINTTerminalRuleCall_0(), semanticObject.getIntValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? annotations+=PlatformAnnotation*)
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (interfaces+=ServiceInterface | services+=Service | messages+=Message | tests+=TestSequence)+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Par
	 *     Par returns Par
	 *
	 * Constraint:
	 *     (name=ID? time=TimeInterval annotations+=PlatformAnnotation* actions+=Action*)
	 */
	protected void sequence_Par(ISerializationContext context, Par semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation*)
	 */
	protected void sequence_Parameter(ISerializationContext context, eu.stamp.mfts.mFTS.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlatformAnnotation returns PlatformAnnotation
	 *
	 * Constraint:
	 *     (name=ANNOTATION_ID (value=STRING | value=EXTERN))
	 */
	protected void sequence_PlatformAnnotation(ISerializationContext context, PlatformAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Send
	 *     Send returns Send
	 *
	 * Constraint:
	 *     (service=[Service|ID] message=[Message|ID] (parameters+=Expression parameters+=Expression*)? annotations+=PlatformAnnotation*)
	 */
	protected void sequence_Send(ISerializationContext context, Send semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Seq
	 *     Seq returns Seq
	 *
	 * Constraint:
	 *     actions+=Action+
	 */
	protected void sequence_Seq(ISerializationContext context, Seq semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ServiceInterface returns ServiceInterface
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation* ((sends+=[Message|ID] sends+=[Message|ID]*) | (receives+=[Message|ID] receives+=[Message|ID]*))*)
	 */
	protected void sequence_ServiceInterface(ISerializationContext context, ServiceInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (name=ID interfaces+=[ServiceInterface|ID] interfaces+=[ServiceInterface|ID]* annotations+=PlatformAnnotation*)
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     stringValue=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MFTSPackage.Literals.STRING_LITERAL__STRING_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MFTSPackage.Literals.STRING_LITERAL__STRING_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getStringValueSTRINGTerminalRuleCall_0(), semanticObject.getStringValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TestSequence returns TestSequence
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation* actions=Seq)
	 */
	protected void sequence_TestSequence(ISerializationContext context, TestSequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimeInterval returns TimeInterval
	 *
	 * Constraint:
	 *     (min=INT max=INT)
	 */
	protected void sequence_TimeInterval(ISerializationContext context, TimeInterval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MFTSPackage.Literals.TIME_INTERVAL__MIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MFTSPackage.Literals.TIME_INTERVAL__MIN));
			if (transientValues.isValueTransient(semanticObject, MFTSPackage.Literals.TIME_INTERVAL__MAX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MFTSPackage.Literals.TIME_INTERVAL__MAX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeIntervalAccess().getMinINTTerminalRuleCall_1_0(), semanticObject.getMin());
		feeder.accept(grammarAccess.getTimeIntervalAccess().getMaxINTTerminalRuleCall_3_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Wait
	 *     Wait returns Wait
	 *
	 * Constraint:
	 *     time=TimeInterval
	 */
	protected void sequence_Wait(ISerializationContext context, Wait semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MFTSPackage.Literals.WAIT__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MFTSPackage.Literals.WAIT__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWaitAccess().getTimeTimeIntervalParserRuleCall_1_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
}
